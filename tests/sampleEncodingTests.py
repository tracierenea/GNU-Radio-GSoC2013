#!/usr/bin/python
from LDPCfunctions import *
from numpy import *
from numpy import matrix

# Example of how to do encoding per Appendix A in Modern Coding
# Theory (Richardson/Urbanke). 

# First, create an H matrix
print '\nTEST 1 - (16,4,3) code generated by',
print ' regularLDPCcodeConstructor:'

H = regularLDPCcodeConstructor(16,3,4)
print 'H:\n', H

############ this is all preprocessing #############################
print 'Running permutation algorithm 100 times to ensure the lowest',
print ' gap is found.'
[betterH, g, t]  = greedyUpperTriangulation(H)

for index in arange(100):
 	[temp_H, temp_g, temp_t]  = greedyUpperTriangulation(H)
 	if temp_g < g:
 		betterH = temp_H
 		g = temp_g
 		t = temp_t
print 'Using this H matrix:\n', betterH
print H.shape
print '  with gap g:', g, 'and t =', t
n = betterH.shape[1]
T = betterH[0:t  , 0:t]
E = betterH[t:t+g, 0:t]
A = betterH[0:t  , t:t+g]
C = betterH[t:t+g, t:t+g]
B = betterH[0:t,   t+g:n]
D = betterH[t:t+g, t+g:n]

print 'So the square and upper triangular T matrix is:\n', T
print 'The other submatrices are:'
print 'E:\n', E
print E.shape
print 'A:\n', A
print A.shape
print 'C:\n', C
print C.shape
print 'B:\n', B
print B.shape
print 'D:\n', D
print D.shape

invTmod2 = invTmod2(T)
a = vstack((T,E))
b = vstack((A,C))
c = vstack((B,D))
TABECDmatrix = hstack((a,b,c))
print TABECDmatrix

############ this is all real-time encoding #########################

# in work
