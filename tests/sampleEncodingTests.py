#!/usr/bin/python
from LDPCfunctions import *
from numpy import *

# Example of how to do encoding per Appendix A in Modern Coding
# Theory (Richardson/Urbanke). 

# First, create an H matrix
# print '\nTEST 1 - (16,4,3) code generated by',
# print ' regularLDPCcodeConstructor:'

# H = regularLDPCcodeConstructor(16,3,4)

# for some reason, the H being created by my function
# is not working - generates a phi of zeros. 

# Pressing on with developing this method using the H matrix from
# example A12, which does seem to work with this coded algorithm

H = array([[0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0],  # 1
	       [1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0],  # 2
	       [0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1],  # 3
	       [0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0],  # 4
	       [1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1],  # 5
	       [1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1]]) # 6

print 'H:\n', H

############ this is all preprocessing #############################
print 'Running permutation algorithm 100 times to ensure the lowest',
print ' gap is found.'
[betterH, g, t]  = greedyUpperTriangulation(H)

for index in arange(100):
 	[temp_H, temp_g, temp_t]  = greedyUpperTriangulation(H)
 	if temp_g < g:
 		betterH = temp_H
 		g = temp_g
 		t = temp_t
print 'Using this H matrix:\n', betterH
print H.shape
print '  with gap g:', g, 'and t =', t
n = betterH.shape[1]
T = betterH[0:t  , 0:t]
E = betterH[t:t+g, 0:t]
A = betterH[0:t  , t:t+g]
C = betterH[t:t+g, t:t+g]
B = betterH[0:t,   t+g:n]
D = betterH[t:t+g, t+g:n]

print 'So the square and upper triangular T matrix is:\n', T
print 'The other submatrices are:'
print 'E:\n', E
print E.shape
print 'A:\n', A
print A.shape
print 'C:\n', C
print C.shape
print 'B:\n', B
print B.shape
print 'D:\n', D
print D.shape

invTmod2array = invMod2(T)
a = vstack((T,E))
b = vstack((A,C))
c = vstack((B,D))
TABECDmatrix = hstack((a,b,c))
print 'TABECD matrix:\n', TABECDmatrix

temp1  = dot(E,invTmod2array) % 2
temp2  = dot(temp1,A) % 2
phi    = (C - temp2) % 2
print 'phi:\n', phi
invPhi = invMod2(phi)

############ this is all real-time encoding #########################

# Problem A.1 gives this s (systematic part of the vector)
s = array([0, 1, 0, 0, 0, 0])

# compute p1 (this method has lowest complexity)
a = dot(B,s) % 2
b = dot(invTmod2array,a) % 2
c = dot(E,b) % 2
d = dot(D,s) % 2
e = d + c % 2
p2 = dot(invPhi,e) % 2
print 'p2:', p2

# compute p2 (this method has lowest complexity)
a = dot(A, p2) % 2
b = dot(B, s) % 2
c = a + b % 2
p1 = dot(invTmod2array,c) % 2
print 'p1:', p1

# concatenate to get x
x = hstack((p1, p2, s))
print 'x:', x

# verify:
print 'Zeros?:', dot(betterH,x) % 2