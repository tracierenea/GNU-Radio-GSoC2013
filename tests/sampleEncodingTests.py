#!/usr/bin/python
from LDPCfunctions import *
from numpy import *

# Example of how to do encoding per Appendix A in Modern Coding
# Theory (Richardson/Urbanke). 

# First, create an H matrix
# print '\nTEST 1 - (16,4,3) code generated by',
# print ' regularLDPCcodeConstructor:'

# H = regularLDPCcodeConstructor(16,3,4)

# for some reason, the H being created by my function
# is not working - generates a phi of zeros. 

# Pressing on with developing this method using the H matrix from
# example A12, which does seem to work with this coded algorithm

H = array([[0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0],  # 1
	       [1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0],  # 2
	       [0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1],  # 3
	       [0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0],  # 4
	       [1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1],  # 5
	       [1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1]]) # 6

print 'H:\n', H

############ this is all preprocessing #############################
print 'Running permutation algorithm 100 times to ensure the lowest',
print '\ngap is found and the resulting phi is nonsingular.'

# set this arbitrarily high to force whole loop on first run
g = 10**10

for index in arange(100):
 	[temp_H, temp_g, temp_t]  = greedyUpperTriangulation(H)

 	if temp_g < g:
 		n = temp_H.shape[1]
		T = temp_H[0:temp_t, 0:temp_t]
		E = temp_H[temp_t:temp_t+temp_g,0:temp_t]
		A = temp_H[0:temp_t,temp_t:temp_t+temp_g]
		C = temp_H[temp_t:temp_t+temp_g,temp_t:temp_t+temp_g]
		B = temp_H[0:temp_t,temp_t+temp_g:n]
		D = temp_H[temp_t:temp_t+temp_g,temp_t+temp_g:n]
		invTmod2array = invMod2(T)
		temp1  = dot(E,invTmod2array) % 2
		temp2  = dot(temp1,A) % 2
		phi    = (C - temp2) % 2
		try:
			# try to take the inverse of phi
			invPhi = invMod2(phi)
		except linalg.linalg.LinAlgError:
			# phi is singular
			continue
		else:
			# phi is nonsingular, so this is our new candidate
			betterH = temp_H.copy()
			g = temp_g
 			t = temp_t

# a = vstack((T,E))
# b = vstack((A,C))
# c = vstack((B,D))
# TABECDmatrix = hstack((a,b,c))
# print 'TABECD matrix:\n', TABECDmatrix

print 'Using this H matrix:\n', betterH
print '  with gap g:', g, 'and t =', t

############ this is all real-time encoding #########################

# Problem A.1 gives this s (systematic part of the vector)
s = array([0, 1, 0, 0, 0, 0])

# compute p1 (this method has lowest complexity)
a = dot(B,s) % 2
b = dot(invTmod2array,a) % 2
c = dot(E,b) % 2
d = dot(D,s) % 2
e = d + c % 2
p2 = dot(invPhi,e) % 2
print 'p2:', p2

# compute p2 (this method has lowest complexity)
a = dot(A, p2) % 2
b = dot(B, s) % 2
c = a + b % 2
p1 = dot(invTmod2array,c) % 2
print 'p1:', p1

# concatenate to get x
x = hstack((p1, p2, s))
print 'x:', x

# verify:
print 'This should be zeros:', dot(betterH,x) % 2